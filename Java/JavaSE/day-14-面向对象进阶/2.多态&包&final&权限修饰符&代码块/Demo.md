# 多态
## 含义
- 对象的多种形态
```
Person p = new Student();
p.work();
```
## 多态的前提
- 有继承/实现关系
- 有父类引用指向子类对象
- 有方法的重写
## 多态的好处
- 使用父类型作为参数，可以接收所有子类对象
- 扩展性&便利性
## 多态调用成员的特点
- 变量调用：编译看左边，运行也看左边
- 方法调用：编译看左边，运行看右边
### 多态调用成员的内存图
![[多态调用的内存图.png]]
## 多态的弊端
- 不能调用子类的**特有功能**
- 在编译时检查左边的父类有没有这个方法，如果没有直接报错
### 解决方案
- 把调用者变回子类类型即可
1. 方案一：
```
Aniaml a = new Dog();
Dog d = (Dog)a;
```
2. 方案二：instanceof
```
Animal a = new Animal();
if (a instanceof Dog){
	Dog d = Dog a;
}else if (a instanceof Cat){
	Cat c = (Cat) a;
}else{
	sout("没有这个选项，无法转换");
}
```
3. 方案三：extends 方案二
```
Animal a = new Animal();
if (a instanceof Dog a){
	d.lookHome();//调用的dog中的非虚方法表中方法
}else if (a instanceof Cat a){
	c.catchMouse();
}else{
	sout("没有这个选项，无法转换");
}
```
# 包&final&权限修饰符&代码块
## 包
### 含义
- 包就是文件夹，用来管理各种不同功能的Java类，方便后期代码维护
- 包名的规则：公司域名的反写+包的作用，需要全部英文小写，见名知意
- com.itheima.domain
com.itheima.domain.Student——全类名 || 全限定名
![[包的含义.png]]
### 导包的由来
```
import com.itheima.domain.Student;
public class Test{
	public static void main(String[] args){
		Student s = new Student;
	}
}
```
### 导包的限制
- 使用同一个包中的类时，不需要导包
- 使用Java.lang包中的类时，不需要导包——String
- 其他情况都需要导包
- 如果同时使用两个包中的同名类，需要用全类名
## final
- 最终的——>不可改变的
### 修饰
- 方法：表明该方法是最终方法，**不能被重写**
- 类：表明为最终类，**不能被继承**
- 变量：变为常量，只能赋值一次了
#### 常量
实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性
##### 命名规范
- 单个单词：全部大写
- 多个单词：全部大写，单词之间用下划线隔开
##### 注：
- final修饰的变量是基本类型：那么变量存储的数据值不能发生改变
- final修饰的变量是引用类型：那么变量存储的**地址值不能改变**，对象内部可以改变
![[final-变量图示.png]]
## 权限修饰符
- 用来控制一个成员能够被访问的范围的
- 可以修饰成员变量、方法、构造方法、内部类
### 权限修饰符分类
![[权限修饰符分类图示.png]]
### 权限修饰符使用规则
- 实际开发中一般只用private
- 成员变量私有
- 方法公开私有
- 如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有
## 代码块
### 局部代码块
![[局部代码块.png]]
### 构造代码块
- 写在成员位置的代码块
- 作用：可以把多个**构造方法**中重复的代码抽取出来
- 执行时机：我们在创建本类对象时，会先执行构造代码块，再执行构造方法
## ⭐静态代码块
### 格式：
static{}
### 特点
- 需要通过static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次
### 使用场景
- 在类的加载的时候，做一些数据初始化的时候使用